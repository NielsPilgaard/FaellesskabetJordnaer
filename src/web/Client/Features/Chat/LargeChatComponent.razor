@using MudExtensions.Enums
@inject IChatService ChatService
@inject IProfileCache ProfileCache
@inject ISnackbar Snackbar
@inject IJSRuntime JsRuntime
@inject IBrowserViewportService BrowserViewportService
@inject ChatSignalRClient ChatSignalRClient
@attribute [Authorize]

@if (_currentUser is null)
{
    return;
}

<MudLoading @bind-Loading="_isLoading" Darken Overlap>
    <MudGrid Style="height: 600px">

        @if ((_activeChat is null && _isMobile) || _isMobile is false)
        {
            <ChatSelector CurrentUser="_currentUser" Chats="_chats" SelectChatCallback="SelectChat" StartNewChatCallback="StartNewChat"/>
        }

        @if (_isMobile is false)
        {
            <MudItem md="1" lg="1" xl="1" xxl="1">
                <MudDivider Vertical DividerType="DividerType.FullWidth"/>
            </MudItem>
        }

        @if (_activeChat is not null)
        {
            <MudItem Class="chat-message-window" xs="12" sm="12" md="8" lg="8" xl="8" xxl="8">
                @if (_isMobile)
                {
                    @*something like a banner is needed here, with display name and back button
                        Use MudAppBar
                    *@
                    <MudScrollToTop OnClick="BackToList"></MudScrollToTop>
                    <MudFab StartIcon="@Icons.Material.Filled.ArrowBack" OnClick="BackToList" Color="Color.Primary"/>
                    <MudText>@_activeChat.GetDisplayName(_currentUser.Id)</MudText>

                }

                <MudList Class="chat-message-list" DisablePadding Dense>

                    <ChatMessageList CurrentUser="_currentUser" ActiveChat="_activeChat"/>


                    <MudAnimate @ref="_messageSuccessfullySentAnimation"
                                AnimationType="AnimationType.Fade"
                                AnimationTiming="AnimationTiming.EaseIn"
                                Delay="500"
                                Selector=".message-sent-successfully-container"/>

                    @if (LastMessageWasSentSuccessfullyByCurrentUser)
                    {
                        <div title="Din besked er blevet sendt" class="message-sent-successfully-container">
                            <MudIcon Icon="@Icons.Material.Outlined.CheckCircleOutline"
                                     Class="message-sent-successfully"/>
                        </div>
                    }

                    <div class="flex-spacer"></div>

                    <MudTextField @bind-Value="_userText"
                                  id="chat-message-input"
                                  FullWidth
                                  Immediate
                                  AutoFocus
                                  Adornment="Adornment.End"
                                  TextUpdateSuppression="false"
                                  OnKeyDown="SendMessageOnEnter"
                                  AdornmentIcon="@Icons.Material.Filled.Send"
                                  AdornmentColor="@(string.IsNullOrEmpty(_userText) ? Color.Default : Color.Primary)"
                                  OnAdornmentClick="SendMessage"/>
                </MudList>
            </MudItem>
        }
    </MudGrid>
</MudLoading>

@code {
    [Parameter]
    public Guid? ChatId { get; set; }

    private UserProfile? _currentUser;
    private List<ChatDto> _chats = new();
    private ChatDto? _activeChat;

    private string _userText = string.Empty;

    private bool _isActiveChatPublished = true;
    private bool _isLoading = true;
    private bool _isMobile = true;

    private MudAnimate _messageSuccessfullySentAnimation = null!;
    private Dictionary<Guid, Guid> _lastSuccessfullySentMessageForChat = new();

    private bool LastMessageWasSentSuccessfullyByCurrentUser
    {
        get
        {
            if (_activeChat is null)
            {
                return false;
            }
            var lastMessage = _activeChat.Messages.LastOrDefault();
            if (lastMessage is null)
            {
                return false;
            }
            var lastMessageIsFromCurrentUser = lastMessage.SenderId == _currentUser!.Id;

            var lastMessageWasSuccessfullySent = _lastSuccessfullySentMessageForChat.TryGetValue(_activeChat.Id, out var lastSuccessfullySentMessage) &&
                                                 lastSuccessfullySentMessage == lastMessage.Id;

            return lastMessageIsFromCurrentUser && lastMessageWasSuccessfullySent;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        _currentUser = await ProfileCache.GetOrCreateProfileAsync();
        if (_currentUser is null)
        {
            Snackbar.Add(ErrorMessages.Something_Went_Wrong_Refresh, Severity.Warning);
            return;
        }

        var currentBreakpoint = await BrowserViewportService.GetCurrentBreakpointAsync();
        _isMobile = currentBreakpoint <= Breakpoint.SmAndDown;

        _chats = await ChatService.GetChats(_currentUser.Id);
        if (ChatId is not null)
        {
            _activeChat = _chats.FirstOrDefault(chat => chat.Id == ChatId);
        }

        ChatSignalRClient.OnChatStarted(chat =>
        {
            if (chat.InitiatorId == _currentUser.Id)
            {
                return;
            }

            var chatDto = chat.ToChatDto();
            chatDto.UnreadMessageCount++;
            _chats.Insert(0, chatDto);

            StateHasChanged();
        });

        ChatSignalRClient.OnMessageReceived(async message =>
        {
            var chat = _chats.FirstOrDefault(chat => chat.Id == message.ChatId);
            if (chat is null)
            {
                return;
            }
            if (message.SenderId == _currentUser.Id)
            {
                _lastSuccessfullySentMessageForChat[chat.Id] = message.Id;
                StateHasChanged();
                await _messageSuccessfullySentAnimation.Refresh();
                return;
            }

            chat.Messages.Add(message);

            if (_activeChat?.Id == chat.Id)
            {
                await ChatService.MarkMessagesAsRead(message.ChatId);
                StateHasChanged();
                await ScrollToBottom();
            }
            else
            {
                _chats = _chats.OrderByDescending(c => c.UnreadMessageCount).ToList();
                chat.UnreadMessageCount++;
                StateHasChanged();
            }
        });
        await ChatSignalRClient.StartAsync();

        _isLoading = false;
    }

    public async Task LoadMessages()
    {
        if (_activeChat is null)
        {
            Snackbar.Add(ErrorMessages.Something_Went_Wrong_Refresh, Severity.Warning);
            return;
        }

        _activeChat.Messages = await ChatService.GetChatMessages(_activeChat.Id);

        StateHasChanged();
    }

    private async Task SelectChat(ChatDto chat)
    {
        _activeChat = chat;
        if (_isActiveChatPublished)
        {
            await LoadMessages();

            await ScrollToBottom();

            await FocusMessageInput();

            if (chat.HasUnreadMessages)
            {
                await ChatService.MarkMessagesAsRead(_activeChat.Id);
                chat.UnreadMessageCount = 0;
            }
        }
    }

    private async Task FocusMessageInput() => await JsRuntime.InvokeVoidAsync("scrollFunctions.focusMessageInput");

    private async Task ScrollToBottom() => await JsRuntime.InvokeVoidAsync("scrollFunctions.scrollToTheBottomOfChat");

    private void BackToList() => _activeChat = null;

    private async Task SendMessage()
    {
        if (_activeChat is null || string.IsNullOrWhiteSpace(_userText))
        {
            return;
        }

        var message = new ChatMessageDto
            {
                ChatId = _activeChat.Id,
                Id = NewId.NextGuid(),
                SentUtc = DateTime.UtcNow,
                SenderId = _currentUser!.Id,
                Text = _userText
            };

        _activeChat.Messages.Add(message);
        _userText = string.Empty;

        if (_isActiveChatPublished)
        {
            await ChatService.SendMessage(message);
        }
        else
        {
            await ChatService.StartChat(_activeChat.ToStartChatCommand(_currentUser!.Id));
            _isActiveChatPublished = true;
        }

        await ScrollToBottom();
    }

    private async Task SendMessageOnEnter(KeyboardEventArgs keyboardEventArgs)
    {
        if (keyboardEventArgs is { Key: "Enter", ShiftKey: false })
        {
            await SendMessage();
        }
    }

    private async Task StartNewChat(IEnumerable<UserSlim> users)
    {
        var userList = users.ToList();
        if (userList.Count == 1)
        {
            var userIdsToFind = new[] { userList.First().Id, _currentUser!.Id };
            var existingChat = _chats.FirstOrDefault(chat => chat.Recipients.Count == 2 &&
                                                             userIdsToFind.All(id => chat.Recipients.Any(recipient => recipient.Id == id)));
            if (existingChat is not null)
            {
                await SelectChat(existingChat);

                return;
            }
        }

        var newChat = new ChatDto
        {
            Id = NewId.NextGuid(),
            Recipients = new List<UserSlim> { _currentUser!.ToUserSlim() },
            LastMessageSentUtc = DateTime.UtcNow,
            StartedUtc = DateTime.UtcNow
        };

        foreach (var user in userList.Where(u => u.Id != _currentUser!.Id))
        {
            newChat.Recipients.Add(new UserSlim
                {
                    DisplayName = user.DisplayName,
                    Id = user.Id,
                    ProfilePictureUrl = user.ProfilePictureUrl
                });
        }

        _chats.Insert(0, newChat);

        _isActiveChatPublished = false;

        await SelectChat(newChat);
    }
}
